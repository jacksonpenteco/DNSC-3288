# -*- coding: utf-8 -*-
"""Housing Prices - DNSC 3288

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lLSWsEaNL0Wvc5_EJ2O4dtxWe6-uFsR5
"""

from sklearn import tree
from sklearn.model_selection import train_test_split
from sklearn.model_selection import cross_val_score
from sklearn.metrics import roc_auc_score, accuracy_score

import numpy as np
import pandas as pd

from matplotlib import pyplot as plt
import seaborn as sns

SEED = 43888 #Random Seed

import sys
import sklearn
version = '.'.join(map(str,sklearn.__version__.split('.')[:2]))
print('Python Version:',version)
print('Scikit-Learn Version:', sklearn.__version__)

"""Data Upload"""

Training = pd.read_csv('train.csv')
Testing = pd.read_csv('test.csv')

"""Data Dictionary"""

from IPython.display import display, HTML
import pandas as pd

data_dictionary = [
    {"Feature": "SalePrice", "Description": "The property's sale price in dollars. This is the target variable."},
    {"Feature": "MSSubClass", "Description": "The building class"},
    {"Feature": "MSZoning", "Description": "The general zoning classification"},
    {"Feature": "LotFrontage", "Description": "Linear feet of street connected to property"},
    {"Feature": "LotArea", "Description": "Lot size in square feet"},
    {"Feature": "Street", "Description": "Type of road access"},
    {"Feature": "Alley", "Description": "Type of alley access"},
    {"Feature": "LotShape", "Description": "General shape of property"},
    {"Feature": "LandContour", "Description": "Flatness of the property"},
    {"Feature": "Utilities", "Description": "Type of utilities available"},
    {"Feature": "LotConfig", "Description": "Lot configuration"},
    {"Feature": "LandSlope", "Description": "Slope of property"},
    {"Feature": "Neighborhood", "Description": "Physical locations within Ames city limits"},
    {"Feature": "Condition1", "Description": "Proximity to main road or railroad"},
    {"Feature": "Condition2", "Description": "Proximity to main road or railroad (if a second is present)"},
    {"Feature": "BldgType", "Description": "Type of dwelling"},
    {"Feature": "HouseStyle", "Description": "Style of dwelling"},
    {"Feature": "OverallQual", "Description": "Overall material and finish quality"},
    {"Feature": "OverallCond", "Description": "Overall condition rating"},
    {"Feature": "YearBuilt", "Description": "Original construction date"},
    {"Feature": "YearRemodAdd", "Description": "Remodel date"},
    {"Feature": "RoofStyle", "Description": "Type of roof"},
    {"Feature": "RoofMatl", "Description": "Roof material"},
    {"Feature": "Exterior1st", "Description": "Exterior covering on house"},
    {"Feature": "Exterior2nd", "Description": "Exterior covering on house (if more than one material)"},
    {"Feature": "MasVnrType", "Description": "Masonry veneer type"},
    {"Feature": "MasVnrArea", "Description": "Masonry veneer area in square feet"},
    {"Feature": "ExterQual", "Description": "Exterior material quality"},
    {"Feature": "ExterCond", "Description": "Present condition of the material on the exterior"},
    {"Feature": "Foundation", "Description": "Type of foundation"},
    {"Feature": "BsmtQual", "Description": "Height of the basement"},
    {"Feature": "BsmtCond", "Description": "General condition of the basement"},
    {"Feature": "BsmtExposure", "Description": "Walkout or garden level basement walls"},
    {"Feature": "BsmtFinType1", "Description": "Quality of basement finished area"},
    {"Feature": "BsmtFinSF1", "Description": "Type 1 finished square feet"},
    {"Feature": "BsmtFinType2", "Description": "Quality of second finished area (if present)"},
    {"Feature": "BsmtFinSF2", "Description": "Type 2 finished square feet"},
    {"Feature": "BsmtUnfSF", "Description": "Unfinished square feet of basement area"},
    {"Feature": "TotalBsmtSF", "Description": "Total square feet of basement area"},
    {"Feature": "Heating", "Description": "Type of heating"},
    {"Feature": "HeatingQC", "Description": "Heating quality and condition"},
    {"Feature": "CentralAir", "Description": "Central air conditioning"},
    {"Feature": "Electrical", "Description": "Electrical system"},
    {"Feature": "1stFlrSF", "Description": "First Floor square feet"},
    {"Feature": "2ndFlrSF", "Description": "Second floor square feet"},
    {"Feature": "LowQualFinSF", "Description": "Low quality finished square feet (all floors)"},
    {"Feature": "GrLivArea", "Description": "Above grade (ground) living area square feet"},
    {"Feature": "BsmtFullBath", "Description": "Basement full bathrooms"},
    {"Feature": "BsmtHalfBath", "Description": "Basement half bathrooms"},
    {"Feature": "FullBath", "Description": "Full bathrooms above grade"},
    {"Feature": "HalfBath", "Description": "Half baths above grade"},
    {"Feature": "Bedroom", "Description": "Number of bedrooms above basement level"},
    {"Feature": "Kitchen", "Description": "Number of kitchens"},
    {"Feature": "KitchenQual", "Description": "Kitchen quality"},
    {"Feature": "TotRmsAbvGrd", "Description": "Total rooms above grade (does not include bathrooms)"},
    {"Feature": "Functional", "Description": "Home functionality rating"},
    {"Feature": "Fireplaces", "Description": "Number of fireplaces"},
    {"Feature": "FireplaceQu", "Description": "Fireplace quality"},
    {"Feature": "GarageType", "Description": "Garage location"},
    {"Feature": "GarageYrBlt", "Description": "Year garage was built"},
    {"Feature": "GarageFinish", "Description": "Interior finish of the garage"},
    {"Feature": "GarageCars", "Description": "Size of garage in car capacity"},
    {"Feature": "GarageArea", "Description": "Size of garage in square feet"},
    {"Feature": "GarageQual", "Description": "Garage quality"},
    {"Feature": "GarageCond", "Description": "Garage condition"},
    {"Feature": "PavedDrive", "Description": "Paved driveway"},
    {"Feature": "WoodDeckSF", "Description": "Wood deck area in square feet"},
    {"Feature": "OpenPorchSF", "Description": "Open porch area in square feet"},
    {"Feature": "EnclosedPorch", "Description": "Enclosed porch area in square feet"},
    {"Feature": "3SsnPorch", "Description": "Three season porch area in square feet"},
    {"Feature": "ScreenPorch", "Description": "Screen porch area in square feet"},
    {"Feature": "PoolArea", "Description": "Pool area in square feet"},
    {"Feature": "PoolQC", "Description": "Pool quality"},
    {"Feature": "Fence", "Description": "Fence quality"},
    {"Feature": "MiscFeature", "Description": "Miscellaneous feature not covered in other categories"},
    {"Feature": "MiscVal", "Description": "$Value of miscellaneous feature"},
    {"Feature": "MoSold", "Description": "Month Sold"},
    {"Feature": "YrSold", "Description": "Year Sold"},
    {"Feature": "SaleType", "Description": "Type of sale"},
    {"Feature": "SaleCondition", "Description": "Condition of sale"}
]

data_dictionary_df = pd.DataFrame(data_dictionary)

# Render the DataFrame as an HTML table with better styling
display(HTML(data_dictionary_df.to_html(index=False, border=1)))

"""Data Cleaning"""

Training.head()

Training.shape

categorical_columns = (['MSZoning', 'Street', 'Alley', 'LotShape', 'LandContour', 'Utilities',
       'LotConfig', 'LandSlope', 'Neighborhood', 'Condition1', 'Condition2',
       'BldgType', 'HouseStyle', 'RoofStyle', 'RoofMatl', 'Exterior1st',
       'Exterior2nd', 'MasVnrType', 'ExterQual', 'ExterCond', 'Foundation',
       'BsmtQual', 'BsmtCond', 'BsmtExposure', 'BsmtFinType1', 'BsmtFinType2',
       'Heating', 'HeatingQC', 'CentralAir', 'Electrical', 'KitchenQual',
       'Functional', 'FireplaceQu', 'GarageType', 'GarageFinish', 'GarageQual',
'GarageCond', 'PavedDrive', 'PoolQC', 'Fence', 'MiscFeature',
       'SaleType', 'SaleCondition'])
# create dummies
Training = pd.get_dummies(Training, columns=categorical_columns, drop_first=True)

_ = Training[Training.columns].hist(bins=50, figsize=(20, 20))

"""#Correlation"""

#
numerical_features = Training.select_dtypes(include=['number']).columns
corr = Training[numerical_features].corr()
corr

#Correlation Heatmap
plt.figure(figsize=(10, 10))
_ = sns.heatmap(corr,
                xticklabels=corr.columns.values,
                yticklabels=corr.columns.values)

"""#Decision Tree"""

from sklearn.tree import DecisionTreeRegressor, plot_tree
from sklearn.metrics import mean_squared_error

target = 'SalePrice'
X_train = Training.select_dtypes(include=['float64', 'int64']).drop(columns=[target, 'Id'], errors='ignore')
y_train = Training[target]

X_test = Testing.select_dtypes(include=['float64', 'int64']).drop(columns=['Id'], errors='ignore')

X_train = X_train.fillna(X_train.median())
X_test = X_test.fillna(X_train.median())

regressor = DecisionTreeRegressor(max_depth=5, random_state=45)

regressor.fit(X_train, y_train)

y_train_pred = regressor.predict(X_train)

rmse = mean_squared_error(y_train, y_train_pred, squared=False)
print(rmse)

test_predictions = regressor.predict(X_test)

output = pd.DataFrame({
    'Id': Testing['Id'],
    'SalePrice': test_predictions
})

output.to_csv('submission.csv', index=False)

plt.figure(figsize=(20, 10))
plot_tree(regressor, feature_names=X_train.columns, filled=True, max_depth=2)
plt.show()

"""#Model"""

import statsmodels.api as sm

X_train = Training.select_dtypes(include=['float64', 'int64']).drop(columns=[target, 'Id'], errors='ignore')
y_train = Training[target]

X_test = Testing.select_dtypes(include=['float64', 'int64']).drop(columns=['Id'], errors='ignore')

X_train = X_train.fillna(X_train.median())
X_test = X_test.fillna(X_train.median())

def backward_stepwise_regression(X, y, significance_level=0.05):
    features = list(X.columns)
    while len(features) > 0:
        X_with_intercept = sm.add_constant(X[features])
        model = sm.OLS(y, X_with_intercept).fit()
        p_values = model.pvalues.iloc[1:]
        max_p_value = p_values.max()

        if max_p_value > significance_level:
            excluded_feature = p_values.idxmax()
            features.remove(excluded_feature)
            print(f"Removed {excluded_feature} with p-value {max_p_value:.4f}")
        else:
            break


    X_with_intercept = sm.add_constant(X[features])
    final_model = sm.OLS(y, X_with_intercept).fit()
    return final_model, features

final_model, selected_features = backward_stepwise_regression(X_train, y_train)

X_train_selected = X_train[selected_features]
X_test_selected = X_test[selected_features]

final_model = sm.OLS(y_train, sm.add_constant(X_train_selected)).fit()

y_test_pred = final_model.predict(sm.add_constant(X_test_selected))

output = pd.DataFrame({'Id': Testing['Id'], 'SalePrice': y_test_pred})
output.to_csv('submission2.csv', index=False)

print("Selected Features:", selected_features)
print(final_model.summary())
print("Predictions saved to 'submission2.csv'")

import pandas as pd
import statsmodels.api as sm
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score

target = 'SalePrice'

X = Training.select_dtypes(include=['float64', 'int64']).drop(columns=[target, 'Id'], errors='ignore')
y = Training[target]

X_train_full, X_test, y_train_full, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
X_train, X_val, y_train, y_val = train_test_split(X_train_full, y_train_full, test_size=0.2, random_state=42)

X_train = X_train.fillna(X_train.median())
X_val = X_val.fillna(X_train.median())
X_test = X_test.fillna(X_train.median())

def backward_stepwise_regression(X, y, significance_level=0.05):
    features = list(X.columns)
    while len(features) > 0:
        X_with_intercept = sm.add_constant(X[features])
        model = sm.OLS(y, X_with_intercept).fit()
        p_values = model.pvalues.iloc[1:]
        max_p_value = p_values.max()

        if max_p_value > significance_level:
            excluded_feature = p_values.idxmax()
            features.remove(excluded_feature)
        else:
            break

    X_with_intercept = sm.add_constant(X[features])
    final_model = sm.OLS(y, X_with_intercept).fit()
    return final_model, features

final_model, selected_features = backward_stepwise_regression(X_train, y_train)

X_train_selected = X_train[selected_features]
X_val_selected = X_val[selected_features]
X_test_selected = X_test[selected_features]

final_model = sm.OLS(y_train, sm.add_constant(X_train_selected)).fit()

y_train_pred = final_model.predict(sm.add_constant(X_train_selected))
y_val_pred = final_model.predict(sm.add_constant(X_val_selected))
y_test_pred = final_model.predict(sm.add_constant(X_test_selected))

r2_train = r2_score(y_train, y_train_pred)
r2_val = r2_score(y_val, y_val_pred)
r2_test = r2_score(y_test, y_test_pred)

print(f"R-squared for Training Set: {r2_train:.4f}")
print(f"R-squared for Validation Set: {r2_val:.4f}")
print(f"R-squared for Test Set: {r2_test:.4f}")

output = pd.DataFrame({'Id': Testing['Id'], 'SalePrice': y_test_pred})
output.to_csv('submission2.csv', index=False)

print("Selected Features:", selected_features)
print(final_model.summary())
print("Predictions saved to 'submission2.csv'")

"""# Ethical Considerations

### Potential negative impacts of using our model:

*  Subjective Data, i.e., Kitchen quality and Quality of basement finished area.
*  Bias in the model would be amplified if data has any bias.
*  Model can become overfit and perform poorly on unseen data.

### Potential uncertainties relating to the impacts of using our model:

*  The model could create a feedback loop in the housing industry.
*  The model could be breaking Fair Housing Laws unintentionally.
*  Making sure all the data collected was with consent and being used ethically
"""